import { Mock, mock } from "ts-jest-mocker";
import { BookHandler } from "../../handlers/book";
import { BookService } from "../../services/book";
import { NextFunction, Response } from "express";
import { Request } from "../../types/express";
import { faker } from "@faker-js/faker";
import { resCode, resMessage } from "../../constants/http-response";
import appError from "../../errors/apperror";

jest.mock("../../services/book.ts");

describe("Book Handler", () => {
  let bookHandler: BookHandler;
  let bookService: Mock<BookService>;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: NextFunction;

  beforeEach(() => {
    bookService = mock(BookService);
    bookHandler = new BookHandler(bookService);

    mockRequest = {};
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      cookie: jest.fn(),
    };
    mockNext = jest.fn();
  });

  const books = {
    data: [
      {
        code: faker.string.alphanumeric(),
        title: faker.lorem.sentence(),
        author: faker.internet.userName(),
        stock: 2,
      },
    ],
    total_data: 1,
    page: 1,
    per_page: 10,
  };

  const page = "1";
  const limit = "10";

  describe("getAllBooks", () => {
    it("should return success message when no error from service", async () => {
      bookService.getAllBooks.mockResolvedValueOnce(books);
      mockRequest.query = { page, limit };

      await bookHandler.getAllBooks(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.OK,
        data: books,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      bookService.getAllBooks.mockRejectedValueOnce(err);
      mockRequest.query = { page, limit };

      try {
        await bookHandler.getAllBooks(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("addBook", () => {
    it("should return success message when no error from service", async () => {
      bookService.addBook.mockResolvedValueOnce();
      mockRequest.body = books.data[0];

      await bookHandler.addBook(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.Created);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successAddBook,
        data: books.data[0],
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      bookService.addBook.mockRejectedValueOnce(err);
      mockRequest.body = books.data[0];

      try {
        await bookHandler.addBook(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("updateBook", () => {
    it("should return success message when no error from service", async () => {
      bookService.updateBook.mockResolvedValueOnce();
      mockRequest.body = books.data[0];

      await bookHandler.updateBook(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successUpdateBook,
        data: books.data[0],
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      bookService.updateBook.mockRejectedValueOnce(err);
      mockRequest.body = books.data[0];

      try {
        await bookHandler.updateBook(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });
});

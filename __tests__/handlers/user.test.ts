import { Mock, mock } from "ts-jest-mocker";
import { UserHandler } from "../../handlers/user";
import { UserService } from "../../services/user";
import { NextFunction, Response } from "express";
import { Request } from "../../types/express";
import { faker } from "@faker-js/faker";
import { resCode, resMessage } from "../../constants/http-response";
import appError from "../../errors/apperror";

jest.mock("../../services/user.ts");

describe("User Handler", () => {
  let userHandler: UserHandler;
  let userService: Mock<UserService>;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: NextFunction;

  beforeEach(() => {
    userService = mock(UserService);
    userHandler = new UserHandler(userService);

    mockRequest = {};
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      cookie: jest.fn(),
    };
    mockNext = jest.fn();
  });

  const users = {
    data: [
      {
        name: faker.internet.userName(),
        email: faker.internet.email(),
        code: faker.string.alphanumeric(),
        borrowed_books: 1,
      },
    ],
    total_data: 1,
    page: 1,
    per_page: 10,
  };
  const role = faker.word.noun();
  const email = faker.internet.email();
  const page = "1";
  const limit = "10";

  describe("getAllUsers", () => {
    it("should return success message when no error from service", async () => {
      userService.getAllUsers.mockResolvedValueOnce(users);
      mockRequest.query = { role, page, limit };

      await userHandler.getAllUsers(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.OK,
        data: users,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      userService.getAllUsers.mockRejectedValueOnce(err);
      mockRequest.query = { role, page, limit };

      try {
        await userHandler.getAllUsers(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("borrowBooks", () => {
    it("should return success message when no error from service", async () => {
      userService.borrowBooks.mockResolvedValueOnce(1);
      mockRequest.body = { book_codes: ["JK-45"] };
      mockResponse.locals = { user: { email } };

      await userHandler.borrowBooks(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successBorrowBook,
        data: { total_borrows: 1 },
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      userService.borrowBooks.mockRejectedValueOnce(err);
      mockRequest.body = { book_codes: ["JK-45"] };
      mockResponse.locals = { user: { email } };

      try {
        await userHandler.borrowBooks(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("returnBooks", () => {
    it("should return success message when no error from service", async () => {
      const expectedResult = { still_borrowed: 1, with_penalty: false };
      userService.returnBooks.mockResolvedValueOnce(expectedResult);
      mockRequest.body = { book_codes: ["JK-45"] };
      mockResponse.locals = { user: { email } };

      await userHandler.returnBooks(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successReturnBook,
        data: expectedResult,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      userService.returnBooks.mockRejectedValueOnce(err);
      mockRequest.body = { book_codes: ["JK-45"] };
      mockResponse.locals = { user: { email } };

      try {
        await userHandler.returnBooks(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });
});

import { mock, Mock } from "ts-jest-mocker";
import { AuthHandler } from "../../handlers/auth";
import { AuthService } from "../../services/auth";
import { configInit, TConfig } from "../../utils/config";
import { NextFunction, Response } from "express";
import { Request } from "../../types/express";
import { resCode, resMessage } from "../../constants/http-response";
import appError from "../../errors/apperror";
import { faker } from "@faker-js/faker";
import { TRouteRequest } from "../../dtos/auth";

jest.mock("../../services/auth.ts");

describe("Auth Handler", () => {
  let authHandler: AuthHandler;
  let authService: Mock<AuthService>;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: NextFunction;
  const config = configInit() as TConfig;

  beforeEach(() => {
    authService = mock(AuthService);
    authHandler = new AuthHandler(authService, config);

    mockRequest = {};
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      cookie: jest.fn(),
    };
    mockNext = jest.fn();
  });

  const token = faker.string.nanoid();
  const email = faker.internet.email();
  const role = faker.word.noun();
  const password = faker.internet.password();
  const user = { email, role, limits: [], additions: {} };
  const roleReq = {
    name: role,
    additions: [],
    limits: [],
    registration: { approvement: false, whitelist: [] },
  };
  const routeReq: TRouteRequest = {
    name: "/",
    restrictions: [{ method: "POST", roles: ["admin"] }],
  };

  describe("register", () => {
    it("should return success message and token on first successful registration", async () => {
      authService.register.mockResolvedValueOnce(token);
      mockRequest.body = { email: faker.internet.email(), role: "admin", additions: {} };

      await authHandler.register(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.Created);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successRegister,
        data: { token },
      });
    });

    it("should return success message on second successful registration as new role", async () => {
      authService.register.mockResolvedValueOnce(null);
      mockRequest.body = { email: faker.internet.email(), role: "admin", additions: {} };

      await authHandler.register(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successRegisterNewRole,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.register.mockRejectedValueOnce(err);
      mockRequest.body = { email: faker.internet.email(), role: "admin", additions: {} };

      try {
        await authHandler.register(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("verifyMmail", () => {
    it("should return success message when no error from service", async () => {
      authService.verifyEmail.mockResolvedValueOnce();
      mockRequest.body = { token };

      await authHandler.verifyEmail(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successVerifyEmail,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.verifyEmail.mockRejectedValueOnce(err);
      mockRequest.body = { token };

      try {
        await authHandler.verifyEmail(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("resendMailToken", () => {
    it("should return success message when no error from service", async () => {
      const expectedResult = { max_date: new Date().toISOString(), token };
      authService.resendMailToken.mockResolvedValueOnce(expectedResult);
      mockRequest.body = { email, role };

      await authHandler.resendMailToken(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successRegister,
        data: { ...expectedResult, role },
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.resendMailToken.mockRejectedValueOnce(err);
      mockRequest.body = { email, role };

      try {
        await authHandler.resendMailToken(
          mockRequest as Request,
          mockResponse as Response,
          mockNext
        );
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("login", () => {
    it("should return success message when no error from service", async () => {
      const expectedResult = { user, token: { accessToken: token, refreshToken: token } };
      authService.login.mockResolvedValueOnce(expectedResult);
      mockRequest.body = { email, role, password };

      await authHandler.login(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successLogin,
        data: expectedResult.user,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.login.mockRejectedValueOnce(err);
      mockRequest.body = { email, role, password };

      try {
        await authHandler.login(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("refreshToken", () => {
    it("should return success message when no error from service", async () => {
      const expectedResult = { accessToken: token, refreshToken: token };
      authService.refreshToken.mockResolvedValueOnce(expectedResult);
      mockRequest.cookies = { refresh_token: token };

      await authHandler.refreshToken(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successRefreshToken,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.refreshToken.mockRejectedValueOnce(err);
      mockRequest.cookies = { refresh_token: token };

      try {
        await authHandler.refreshToken(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("verifyPassword", () => {
    it("should return success message when no error from service", async () => {
      authService.verifyPassword.mockResolvedValueOnce();
      mockRequest.body = { password };
      mockResponse.locals = { user: { email, role } };

      await authHandler.verifyPassword(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successVerifyPassword,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.verifyPassword.mockRejectedValueOnce(err);
      mockRequest.body = { password };
      mockResponse.locals = { user: { email, role } };

      try {
        await authHandler.verifyPassword(
          mockRequest as Request,
          mockResponse as Response,
          mockNext
        );
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("changePassword", () => {
    it("should return success message when no error from service", async () => {
      authService.changePassword.mockResolvedValueOnce();
      mockRequest.body = { password };
      mockResponse.locals = { user: { email, role } };

      await authHandler.changePassword(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successChangePassword,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.changePassword.mockRejectedValueOnce(err);
      mockRequest.body = { password };
      mockResponse.locals = { user: { email, role } };

      try {
        await authHandler.changePassword(
          mockRequest as Request,
          mockResponse as Response,
          mockNext
        );
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("mailForgotPassword", () => {
    it("should return success message when no error from service", async () => {
      const expectedResult = { max_date: new Date().toISOString(), token };
      authService.mailForgotPassword.mockResolvedValueOnce(expectedResult);
      mockRequest.body = { email, role };

      await authHandler.mailForgotPassword(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successSendResetPassAccess,
        data: { ...expectedResult, role },
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.mailForgotPassword.mockRejectedValueOnce(err);
      mockRequest.body = { email, role };

      try {
        await authHandler.mailForgotPassword(
          mockRequest as Request,
          mockResponse as Response,
          mockNext
        );
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("resetPassword", () => {
    it("should return success message when no error from service", async () => {
      authService.resetPassword.mockResolvedValueOnce();
      mockRequest.body = { password, email, role, token };

      await authHandler.resetPassword(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successResetPassword,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.resetPassword.mockRejectedValueOnce(err);
      mockRequest.body = { password };
      mockResponse.locals = { user: { email, role } };

      try {
        await authHandler.resetPassword(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("logout", () => {
    it("should return success message when no error from service", async () => {
      await authHandler.logout(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successLogout,
      });
    });
  });

  describe("addRole", () => {
    it("should return success message when no error from service", async () => {
      authService.addRole.mockResolvedValueOnce(roleReq);
      mockRequest.body = roleReq;

      await authHandler.addRole(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.Created);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successAddRole,
        data: roleReq,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.addRole.mockRejectedValueOnce(err);
      mockRequest.body = roleReq;

      try {
        await authHandler.addRole(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("updateRole", () => {
    it("should return success message when no error from service", async () => {
      authService.updateRole.mockResolvedValueOnce(roleReq);
      mockRequest.body = roleReq;

      await authHandler.updateRole(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successUpdateRole,
        data: roleReq,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.updateRole.mockRejectedValueOnce(err);
      mockRequest.body = roleReq;

      try {
        await authHandler.updateRole(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("addRoute", () => {
    it("should return success message when no error from service", async () => {
      authService.addRoute.mockResolvedValueOnce(routeReq);
      mockRequest.body = roleReq;

      await authHandler.addRoute(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.Created);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successAddRoute,
        data: routeReq,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.addRoute.mockRejectedValueOnce(err);
      mockRequest.body = routeReq;

      try {
        await authHandler.addRoute(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });

  describe("updateRoute", () => {
    it("should return success message when no error from service", async () => {
      authService.updateRoute.mockResolvedValueOnce(routeReq);
      mockRequest.body = routeReq;

      await authHandler.updateRoute(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(resCode.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({
        message: resMessage.successUpdateRoute,
        data: routeReq,
      });
    });

    it("should return error message generated by service layer when any error", async () => {
      const err = appError.internalServer(new Error("error"));
      authService.updateRoute.mockRejectedValueOnce(err);
      mockRequest.body = routeReq;

      try {
        await authHandler.updateRoute(mockRequest as Request, mockResponse as Response, mockNext);
      } catch (error) {
        expect(error).toEqual(err);
      }
    });
  });
});
